<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset='utf-8'>
    <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/unsemantic/1.1.3/unsemantic-grid-responsive.min.css'>
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }

      h1, h2, h3, h4 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      h4 {
        font-size: 30px;
        margin: 1em 0;
      }

      h1 strong, h2 strong, h3 strong, h4 strong, h5 strong, h6 strong {
        text-decoration: underline;
      }

      strong em {
        text-decoration: underline;
      }

      center {
        margin: 1em 0;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }

      .remark-inline-code {
        background-color: #dddddd;
      }

      .remark-slide-scaler {
        overflow-y: scroll;
      }

      .container {
        clear: both;
      }

      ul li {
        margin-top: 0.4em;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      table th, td {
        padding: 0.2em;
      }

      table tbody th, td {
        border-top: 1px solid #c0c0c0;
      }

      blockquote {
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <textarea id='source'>
# Git Introduction

This is a condensed version of the first chapters of the [Git Book](https://git-scm.com/book/en/v2), which you should read if you want more detailed information on the subject.

---

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->


- [What is Git?](#what-is-git)
- [What is version control?](#what-is-version-control)
- [A short history](#a-short-history)
  - [**Local** version control systems](#local-version-control-systems)
  - [**Centralized** version control systems](#centralized-version-control-systems)
  - [**Distributed** version control systems](#distributed-version-control-systems)
- [Git basics](#git-basics)
  - [Snapshots, not differences](#snapshots-not-differences)
  - [Nearly every operation is local](#nearly-every-operation-is-local)
  - [Git has integrity](#git-has-integrity)
  - [What's in a Git project?](#whats-in-a-git-project)
  - [The three states](#the-three-states)
- [Getting started](#getting-started)
  - [Installing Git](#installing-git)
  - [First-time Git setup](#first-time-git-setup)
  - [Creating a new repository](#creating-a-new-repository)
  - [Checking the status of your files](#checking-the-status-of-your-files)
  - [Adding new files](#adding-new-files)
  - [Tracking new files](#tracking-new-files)
  - [Committing your changes](#committing-your-changes)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->





---
## What is Git?

<a href='https://git-scm.com'><img src='images/git-logo.png' width='30%' /></a>

Git is a **version control system (VCS)** originally developed by Linus Torvalds, the creator of Linux.
Its goals are:

* **Speed**
* **Simple** design
* Strong support for **non-linear development** (thousands of parallel branches)
* Fully **distributed**
* Able to handle **large projects** like the Linux kernel efficiently (speed and data size)





---
## What is version control?

> A system that records changes to a file or set of files over time so that you can recall specific versions later.

<p class='center'><img src='images/commits.png' width='50%' /></p>

What can I do with it?

* **Revert** files back to a previous state.
* Revert the entire project back to a previous state.
* **Compare** changes over time.
* See who last modified something that might be causing a problem, who introduced an issue and when, and more.
* **Recover** if you screw things up or lose files.





---

class: center, middle 

## A short history







---
### **Local** version control systems

.grid-60[

You can manually copy your files into another directory to keep old versions.

Systems such as [RCS][rcs] were developed to automate this process.
]
.grid-40[

<img src='images/local-vcs.png' width='100%' />
]
.container[

**But:**

* It is easy to forget which directory you’re in and accidentally write to the wrong file or copy over files you don’t mean to.
* This is limited to your computer: how do you **collaborate** with other people?




]
---
### **Centralized** version control systems

.grid-60[

Systems such as [CVS][cvs], [Subversion][svn], and [Perforce][perforce] have a **single server** that contains all the versioned files,
and clients check out files from that central place.

You can **collaborate** with other people through the server,
and administrators have **fine-grained control** over who can do what.
]
.grid-40[

<img src='images/centralized-vcs.png' width='100%' />
]
.container[

**But:**

* The centralized server is a **single point of failure**.
  If it goes down, then nobody can collaborate at all or save versioned change to anything they're working on.
* If the server's hard disk becomes corrupt and proper backups haven't been kept, you **lose the entire history** of the project except whatever single snapshots people happen to have on their local machines.




]
---
### **Distributed** version control systems

.grid-50[

Systems such as [Git][git], [Mercurial][mercurial], [Bazaar][bazaar] or [Darcs][darcs] are **distributed**.
Clients don't just check out the latest snapshot of the files: they **fully mirror** the repository.

* If any server dies, any of the client repositories can be copied back up to the server to **restore** it.
* You can **collaborate** with different groups of people in different ways simultaneously within the same project.
  This allows you to set up [several types of workflows][distributed-workflows] that aren't possible in centralized systems, such as hierarchical models.
]
.grid-50[

<img src='images/distributed-vcs.png' width='100%' />




]
---

class: center, middle 

## Git basics







---
### Snapshots, not differences

.grid-50[

Other VCSs, like Subversion, store information as a list of file-based **changes**.

Git thinks of its data more like a set of **snapshots** of a miniature filesystem.

Every time you save the state of your project in Git, it basically takes a picture of what all your files look like at that moment and stores a reference to that snapshot.
To be efficient, **if files have not changed, Git doesn't store the file again**, just a link to the previous identical file it has already stored.
Git thinks about its data more like a stream of snapshots.
]
.grid-50[

**Changes**

<img src='images/deltas.png' width='100%' />

**Snapshots**

<img src='images/snapshots.png' width='100%' />




]
---
### Nearly every operation is local

Most operations in Git only need local files and resources to operate.
Because you have the entire history of the project right there on your local disk, most operations seem almost instantaneous:

* To browse the history of the project, Git simply reads it directly from your local database.
* To see the changes introduced in a file since a month ago, Git can look up the file a month ago and do a local difference calculation.
* If you're offline, you can commit happily until you get to a network connection to upload.





---
### Git has integrity

Everything in Git is check-summed before it is stored and is then referred to by that **checksum**.
This means it's impossible to change the contents of any file or directory without Git knowing about it.
This functionality is built into Git at the lowest levels and is integral to its philosophy.
You can’t lose information in transit or get file corruption without Git being able to detect it.

The mechanism that Git uses for this checksumming is called a [SHA-1][sha1] hash.
This is a 40-character string composed of hexadecimal characters (0–9 and a–f) and calculated based on the contents of a file or directory structure in Git.
A SHA-1 hash looks something like this:

```
24b9da6552252987aa493b52f8696cd6d3b00373
```

You will see these hash values all over the place in Git because it uses them so much.
In fact, Git stores everything in its database **not by file name but by the hash value of its contents**.





---
### What's in a Git project?

The file structure in a Git project looks like this:

```txt
my-project:
  .git:
    HEAD
    config
    hooks
    index
    objects
    ...
  file1.txt
  file2.txt
  dir:
    file3.txt
```

A Git project has three main sections:

* The Git directory
* The working directory
* The staging area

---
#### The Git directory

The Git directory is where Git stores the metadata and object database for your project: all the **snapshots** of the different **versions** of your files.
This is the most important part of Git, and it is what is copied when you clone a repository from another computer.

It's located in the `.git` directory in the project's directory:

```txt
my-project:
* .git:
*   HEAD
*   config
*   hooks
*   index
*   objects
*   ...
  file1.txt
  file2.txt
  dir:
    file3.txt
```

There's no reason to modify any of the files in this directory yourself.
You could easily corrupt the Git repository.

---
#### The working directory (also called the working tree)

The working directory is a **single checkout of one version** of the project: these are **the files you are currently working on**.
These files are pulled out of the compressed database in the Git directory and placed in your project's directory for you to use or modify:

```txt
*my-project:
  .git:
    HEAD
    config
    hooks
    index
    objects
    ...
* file1.txt
* file2.txt
* dir:
*   file3.txt
```

---
#### The staging area (also called the index)

The staging area is a file, generally contained in your Git directory, that stores information about **what will go into your next commit**.

Before file snapshots are committed in the Git directory, they must go through the *staging area*.

```txt
my-project:
  .git:
    HEAD
    config
    hooks
*   index
    objects
    ...
  file1.txt
  file2.txt
  dir:
    file3.txt
```





---
### The three states

This is one of the **_most important things to remember about Git_**.

Git has three main states that your files can reside in: *committed*, *modified*, and *staged*:

* **Committed** means that the data is safely stored in your local database (the *Git directory*).
* **Modified** means that you have changed the file but have not committed it to your database yet.
* **Staged** means that you have marked a *new* or *modified* file in its current version to go into your next commit snapshot.
  It is in the *staging area*.

---
#### The basic Git workflow

The basic Git workflow goes something like this:

<p class='center'><img src='images/areas.png' width='60%' /></p>

* You **check out** a specific version of your files into the *working directory*.
* You **modify** files in your *working directory*.
* You **stage** the files, adding snapshots of them to your *staging area*.
* You do a **commit**, which takes the files as they are in the *staging area* and stores that snapshot permanently to your *Git directory*.





---
## Getting started

The rest of this documentation is a tutorial where you will learn how to:

* Configure Git for the first time
* Create a new repository
* Check the status of your files
* Track new files
* Stage and commit modified files
* Remove files
* Move files
* Ignore files





---
### Installing Git

There are a lot of different ways to use Git: the original command line tools and various GUIs of varying capabilities.
But the command line is the only place you can run **all** Git commands with all their options.

If you know how to run the command line version, you can probably also figure out how to run the GUI version, while the opposite is not necessarily true.
So the **command line** is what we will use.

Some of you may already have Git installed.
Run the following command in a terminal to make sure:

```bash
$> git --version
git version 2.11.0
```

If you don't have it, follow these [installation instructions][install-git] to install Git on your machine.





---
### First-time Git setup

Now that you have Git, you must configure your **identity**: your user name and e-mail address.
This is important because every Git commit uses this information, and it's *immutably* baked into every commit you make.

Use the `git config` command to do this:

```bash
$> git config --global user.name "John Doe"
$> git config --global user.email john.doe@example.com
```

You can also run the command with the `--list` option to check that the settings were successfully applied:

```bash
$> git config --list
user.name=John Doe
user.email=john.doe@example.com
```

Note that with the `--global` option, Git will store these settings in your user configuration file (`~/.gitconfig`),
so you only need to do this **once on any given computer**.
You can also change them at any time by running the commands again.





---
### Creating a new repository

Let's get started by creating a directory for our new project:

```bash
$> cd
$> mkdir hello-project
```

Go into the directory and run `git init` to create a Git repository:

```bash
$> cd hello-project
$> git init
Initialized empty Git repository in ~/hello-project
```

This creates a Git directory (`.git`) with an empty object database.
At this point, nothing in your project is tracked yet.





---
### Checking the status of your files

The main tool you use to determine which files are in which state is the `git status` command.
If you run it in the repo you just created, you should see something like this:

```bash
$> git status
On branch master

Initial commit

nothing to commit (create/copy files and use "git add" to track)
```

This means you have an empty repo with no commits, and a clean *working directory* – there is nothing there.

As you can see, Git often helps you by telling you what you can do next: you need to start adding some files.





---
### Adding new files

Write "Hello World" into a `hello.txt` file in the project's directory and re-run the command:

```bash
$> echo "Hello World" > hello.txt
$> git status
On branch master

Initial commit

Untracked files:
  (use "git add <file>..." to include in what will be committed)

  hello.txt

nothing added to commit but untracked files present (use "git add" to track)
```

You can see that your new file is **untracked**.
This means that Git sees a file you didn't have in the previous commit (snapshot).

Git won't start including it in your commit snapshots until you **explicitly** tell it to do so.
It does this so you don't accidentally begin including huge generated binary files or other files that you did not mean to include.





---
### Tracking new files

In order to begin tracking a new file, you must use the `git add` command:

```bash
$> git add hello.txt
$> git status
On branch master

Initial commit

Changes to be committed:
  (use "git rm --cached <file>..." to unstage)

    new file:   hello.txt
```

Your file is now **staged**.
You can see that it is because it's under the *Changes to be committed* heading.
If you commit at this point, the version of the file at the time you ran `git add` is what will be in the historical snapshot.

**Tracking all the files in a directory:** Note that the path you give to `git add` can be a directory.
For example: `git add dir` would recursively stage all the files within `dir`, or `git add .` everything under the current directory.





---
#### Checking staged changes

You can check what you have staged with the `git diff` command:

```diff
$> git diff --staged
diff --git a/hello.txt b/hello.txt
new file mode 100644
index 0000000..557db03
--- /dev/null
+++ b/hello.txt
@@ -0,0 +1 @@
+Hello World
```

The output indicates that `hello.txt` is a `new file`.
It also shows you the new content that will be committed: the lines starting with a `+` sign at the end, in this case just the one "Hello World" line.





---
### Committing your changes

Now that your staging area is set up the way you want it, you can commit your changes.

Committing is done with the `git commit` command.
When you commit, you must provide a **message** that describes the changes you are committing.
You should always write relevant commit messages, as they are visible later in the commit history and can help you retrieve what you need from old versions of your project.

```bash
$> git commit -m "Add hello file"
[master (root-commit) 99da9e4] Add hello file
 1 file changed, 1 insertion(+)
 create mode 100644 hello.txt
```





[rcs]: https://en.wikipedia.org/wiki/Revision_Control_System
[cvs]: https://en.wikipedia.org/wiki/Concurrent_Versions_System
[svn]: https://subversion.apache.org/
[perforce]: https://en.wikipedia.org/wiki/Perforce_Helix
[git]: https://git-scm.com/
[mercurial]: https://www.mercurial-scm.org/
[bazaar]: http://bazaar.canonical.com/
[darcs]: http://darcs.net/
[distributed-workflows]: https://git-scm.com/book/en/v2/Distributed-Git-Distributed-Workflows
[sha1]: https://en.wikipedia.org/wiki/SHA-1
[install-git]: https://git-scm.com/book/en/v2/Getting-Started-Installing-Git

    </textarea>
    <script src='https://remarkjs.com/downloads/remark-latest.min.js'></script>
    <script>
      var slideshow = remark.create({
        navigation: {
          scroll: false
        },
        highlightLines: true,
        highlightSpans: true,
        countIncrementalSlides: false
      });
    </script>
  </body>
</html>
