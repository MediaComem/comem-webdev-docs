<!DOCTYPE html>
<html>
  <head>
    <title>Command Line Introduction (COMEM+ Web Dev)</title>
    <meta charset='utf-8'>

    <link rel='stylesheet' href='../../assets/unsemantic-grid-base.css'>
    <link rel='stylesheet' href='../../assets/unsemantic-grid-desktop.css'>

    <link rel='stylesheet' href='../../assets/fonts/YanoneKaffeesatz/YanoneKaffeesatz.css'>
    <link rel='stylesheet' href='../../assets/fonts/DroidSerif/DroidSerif.css'>
    <link rel='stylesheet' href='../../assets/fonts/UbuntuMono/UbuntuMono.css'>

    <style>
      body {
        font-family: 'Droid Serif';
      }

      h1, h2, h3, h4 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }

      h4 {
        font-size: 30px;
        margin: 1em 0;
      }

      h1 strong, h2 strong, h3 strong, h4 strong, h5 strong, h6 strong {
        text-decoration: underline;
      }

      .image-header h2, .image-header h3, .image-header h4, .image-header h5 .image-header h6 {
        display: none;
      }

      strong em {
        text-decoration: underline;
      }

      center {
        margin: 1em 0;
      }

      .remark-code, .remark-inline-code {
        font-family: 'Ubuntu Mono';
      }

      .remark-inline-code {
        padding: 0 2px;
        background-color: #eee;
        color: indianred;
        border-radius: 3px;
        border: thin solid #dddddd;
      }

      .remark-slide-content p:first-child {
        margin-top: 0;
      }

      .container {
        clear: both;
      }

      ul li {
        margin-top: 0.4em;
      }

      table {
        width: 100%;
        border-collapse: collapse;
      }

      table th, td {
        padding: 0.2em 0.4em;
      }

      table tbody th, td {
        border-top: 1px solid #c0c0c0;
      }

      pre:first-child {
        margin-top: 0;
      }

      blockquote {
        font-style: italic;
        border-left: 5px solid khaki;
        margin-left: 0;
        padding-left: 35px;
      }

      .center blockquote {
        margin-right: 0;
        padding-right: 35px;
        border-right: 5px solid khaki;
      }

      #slide-logo {
        position: absolute;
        top: 0;
        left: 0;
      }

      #slide-logo img {
        height: 60px;
      }

      .breadcrumbs {
        position: absolute;
        top: 15px;
        left: 5.333em;
        font-size: 15px;
        color: #c0c0c0;
      }

      .breadcrumbs a {
        color: #c0c0c0;
        text-decoration: none;
      }

      .breadcrumbs a:hover {
        text-decoration: underline;
      }

      .center.middle .breadcrumbs {
        display: none;
      }

      #slide-links {
        position: absolute;
        top: 15px;
        right: 15px;
        font-size: 15px;
        text-align: right;
      }
	  
	  .gitbash {
		text-align: center;
	  }
	  .gitbash > img {
		width: 80%;
	  }
    </style>
  </head>
  <body>

    <!-- Slides top-left logo -->
    <span id='slide-logo' style='display:none;'><a href='http://www.heig-vd.ch/'><img src='../../assets/heig.png' /></a></span>

    <!-- Slides top-right links -->
    <div id='slide-links' style='display:none;'>
      <!-- GitHub link -->
      <a href='https://github.com/MediaComem/comem-webdev/tree/148df251a845a367abf5db0e7445652eb714118a/subjects/cli/'><img src='../../assets/github.svg' width='24' height='24' alt='Source code' title='GitHub' /></a>
      <!-- Home link -->
      <a class='home-link' href='https://mediacomem.github.io/comem-webdev-docs/'><img src='../../assets/home.svg' width='24' height='24' alt='Home' title='Home' /></a>
    </div>

    <!-- Remark slides -->
    <textarea id='source'>
# Command Line Introduction

This material is used in [COMEM+](http://www.heig-vd.ch/comem) [web development courses](https://github.com/MediaComem/comem-webdev).




---
## What is the Command Line Interface (CLI)

.breadcrumbs[<a href="#1">Command Line Introduction</a>]

The CLI is a tool that allows you to use your computer by writing what you want to do (i.e. **commands**), instead of clicking on things.

It's installed on computers (almost) since the beginnings of time, but it has evolved a little since then. It usually looks something like this:

<p class='center'><img src='images/cli.jpg' width='100%' /></p>

---
### Why use it

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#2">What is the Command Line Interface (CLI)</a>]

CLI is not very user-friendly or visually appealing but it has several advantages:

* Requires very **few resources**
* Can be easily **automated** through scripting
* Is ultimatly **more powerful and efficient** than any GUI

For these reasons, a lot of tools _(especially development tools)_ don't have any GUI and are only usable through a CLI.

**Thus, the CLI is a required tool for any nowadays developer.**

---
### Open a CLI

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#2">What is the Command Line Interface (CLI)</a>]

**CLI are available in every actual OS.**

.grid-50[

On **UNIX-like** systems _(like MacOS or Linux)_, it's called the **Terminal**.

You can use it right away, as it's the _de-facto_ standard.


]
.grid-50[

On **Windows**, the default CLI is called **Invite de commandes** or **cmd**.

But it does not use the same syntax than UNIX-like CLI _(plus, it's bad)_.

> **You'll need to install an alternative.**


]
---
### Install Git Bash (Windows users only)

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#2">What is the Command Line Interface (CLI)</a>]

You're going to install **Git Bash**, an alternative CLI that emulates a UNIX-like terminal on Windows.

.grid-30[

<p class='gitbash'><img src='images/gitbashlogo.png' /></p>


]
.grid-70[

You can download the **Git Bash Installer** on the [Git for Windows website][gitbash].

When it's done, install the software, without changing any default options.

Then, search and open the **Git Bash** software.


]
.container[

> Installing **Git Bash** will also install **Git** and **Git GUI** _(see [the slide-deck about Git][slide-git] for more information)_.


]
---
## How to use the CLI

.breadcrumbs[<a href="#1">Command Line Introduction</a>]

When you open the CLI you should find a blank screen with something like this:

```bash
$>
```
These symbols represent **the prompt** and are used to indicate that you have the lead, that is the computer is waiting for you to type something for it to execute.

> At anytime, hit the `Ctrl + c` command to stop any running task and get the lead back.

**For consistency, we will always use the `$>` symbols to represent the prompt.**

???

Please note that, depending on your OS and your CLI, **the prompt can be composed of different characters**.

When the computer's working, the prompt disappear and you won't have the lead until the prompt reappear again.

---
### Writing commands

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

A command is a word that you have to type on the CLI, that will tell the computer what it have to do.

The syntax for using command could be resumed like this:

```bash
$> name arg1 arg2 arg3 ...
```
**Note the use of space to separate the differents elements of a command.**

* `name` represents the name of the command you want to execute
* `arg1 arg2 arg3 ...` represent additionnal information about the command, **each of them separeted by a space**.

---
### How and what

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

There are two types of arguments to use with a command (if needed):

.grid-50[

**Options** specify **how** the command will behave.

They are identifiable by the `-` or `--` that precedes them.

```bash
$> ls -l --all
```

We use the `ls` command to list the content of the current directory. The options tell `ls` **how** it should do so:
* `--all` tells it to print all elements
* `-l` tells it to print elements in a list format, rather than on one line.


]
.grid-50[

**Arguments** specify **what** will be used by or is the subject of the command.

They are preceded by nothing.

```bash
$> cd /Users/Batman
```
Here, we use the `cd` command to move to another directory.

And the argument `/Users/Batman` tells the command **what** directory we want to move to.


]
???

In the **first example**, we use the `ls` command to list elements in the current directory. We also use options to tell `ls` how it should print elements:
* `--all` tells it to print all elements
* `-l` tells it to print elements in a list format, rather than on one line.

---
### Command : `help`

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

The first command you'd like to type is the `help` command.

As its name implies, it's designed to **give you some help** depending on the context.

Executing the command alone will bring up a **list of available commands**.

```bash
$> help
```
Executing it with the name of a command will bring up **all you need to know about said command**:

```bash
$> help help
```
This `help` command is only available for **system's commands**, but most of the tools that you'll install offer help through the `--help` argument:

```bash
$> [command-name] --help
```
---
#### Interactive helps

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a> > <a href="#9">Command : `help`</a>]

Some helps or commands will print their result all over the screen, effectively hidding the prompt or previous interactions.

Usually, it means that these helps or commands have content that takes more than one screen to be shown.

You can "scroll" down  line-by-line using the `Enter` key, each stroke printing one more line at the bottom of the screen.

To quit these helps or commands, use the `q` key.

---
#### Unix Command Syntax

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a> > <a href="#9">Command : `help`</a>]

When calling the `help` function or looking up some documentation, you could eventually found some strange lines that apparently makes no sense, like:

```bash
cd [-L|[-P [-e]] [-@]] [dir]
```

Here are some explanations:

* `[]`: Whatever's inside is **optionnal** (ex: `[-e]`).
* `|`: You have to **chose between** options (ex: `-L|-P`).
* `...`: Whatever's before can be **repeated** (ex: `[options ...]`).

> Depending on the documentation, you could also found symbols like this:
> 
> * `<value>` = **Don't write that**. Replace it by a value that you should provide.


---
### Command : `pwd`

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

When the CLI starts, it places you in your **personnal directory**.

From there you can navigate your filesystem to go to other directories _(more on that later)_.

But first, you might want to check **where** you currently are.

To do this, use the `pwd` command:

```bash
$> pwd
/Users/Batman
```

> The `pwd` command, that means "print working directory", gives you the absolute path to the directory you're currently in.

---
### Command : `ls`

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

Now that you know where you are, you might want to know **what your current directory is containing**.

To do this, use the `ls` command:

```bash
$> ls
(lots and lots of files)
```
> The `ls` command, that means "local storage", lists the files and directories that the current directory contains.

By default, `ls` doesn't list **hidden elements**.

If you want it to do that, you need to pass the argument `--all` (or `-a`):

```bash
$> ls -a
(lots and lots of files, including the hidden ones)
```

---
### Command : `cd`

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

It's time to go out a little and move to another directory.

Suppose you have a _"Documents"_ directory in your personnal directory, that contains another directory, _"TopSecret"_, to which you want to go.

To do this, use the `cd` command, passing it as argument **the path to the directory** you want to go to.

```bash
(You can use relative path...)
$> pwd
/Users/Batman
$> cd Documents/TopSecret

(...or use absolute path)
$> cd /Users/Batman/Documents/TopSecret
```
> While you type the name of directories or files, hit the `Tab` key after having entered some letters and your CLI can try and autocomplete the name.

???

```bash
$> cd /Us
(Hit the Tab key and the CLI completes the name)
$> cd /Users
```
If there is more than one possible name with this letters, the CLI will do nothing. Hitting the `Tab` key a second time will list all the possibilities matching the letters you typed.

```bash
$> pwd
/Users/Batman

$> cd Do
(Hitting the Tab key will fail)

$> cd Do
(Hitting it again list the possibilites)
Documents/ Downloads/
```
---
#### `cd` shortcuts

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a> > <a href="#14">Command : `cd`</a>]

* To go back one directory at a time, use the `..` shortcut (**don't forget the space!**):
```bash
$> pwd
/Users/Batman/Documents
$> cd ..
$> pwd
/Users/Batman
```

* You can also drag and drop a directory from your Explorer or your Finder to the CLI to see its absolute path automaticaly written.
```bash
$> cd
(Drag and drop a directory from your Explorer/Finder, and...)
$> cd /Users/Batman/Pictures/
```

* At anytime and from anywhere, you can return to your **personnal directory** with the `cd` command, without any argument (or with the `~`):
```bash
$> cd
$> pwd
/Users/Batman
```

???
> To type the `~` character, use this combination:
> * `AltGr + ^` on **Windows**
> * `Alt + n` on **Mac**

---
#### Special note

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a> > <a href="#14">Command : `cd`</a>]

Throughout this course, you will often found the following line of information (_or something resembling it_):

```bash
$> cd path/to/folder
```

This means that you should use **the path that leads to the directory in which you store your projects**.

> You shouldn't **actually write** `path/to/folder`.
> 
> It will obviously fail, unless you happen to have a `path` directory that contains a `to` directory that contains a `folder` directory...

---
### Command : `mkdir`

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#6">How to use the CLI</a>]

You can create directories with the CLI.

To do this, you need to use the `mkdir` command, passing it either...
* the **name** of the directory to create, if you want to create it in the current directory
* 
```bash
$> mkdir BatmobileSchematics
```
* the **path** to the directory, if you want to create it elsewhere
* 
```bash
$> mkdir /Users/Batman/Documents/TopSecret/BatmobileSchematics
```
> All directories but the last should be already existing.

???

If you want to create a directory that should be inside another directory that doesn't exist, `mkdir` will raise an error by default.

But if you pass it the `-p` argument, `mkdir` will create all the non-existing directories

```bash
$> ls
Project/ Documents/ Files/

$> mkdir Pictures/Vacation/Gotham/
mkdir: Pictures: No such file or directory

$> mkdir -p Pictures/Vacation/Gotham
```

---
## Naming things when using CLI

.breadcrumbs[<a href="#1">Command Line Introduction</a>]

You should avoid using (in directories et files name):

* **spaces** _(they're used to separate arguments in command)_
* **accentuated characters** 

They can cause **errors** in some scripts or tools, and will inevitably complicate using the CLI.

```bash
(Will not work)
$> cd ./Why So Serious/
```
> This command will be interpreted as a call to the `cd` command with three arguments : `./Why`, `So` and `Serious/`.

You **can** use names with space, but you have to **escape** them first, using **quotation marks** around:

```bash
(This will work)
$> cd ./"Why So Serious"/
```
---
## For Windows Users

.breadcrumbs[<a href="#1">Command Line Introduction</a>]

**Reference to drives**

To reference or use your drives (`C:`, `D:`, etc), use the following notation:

```bash
$> cd /c
$> cd /d
```
----
**Copy/Paste**

Since the `Ctrl + c` key ise used to stop the current process, it can't be used as a shortcut for copy things from the CLI.

Instead, Git Bash has two shortcuts custom shortcuts:
* `Ctrl + Insert` to **copy** things from the CLI
* `Shift + Insert` to **paste** things to the CLI

> You can still use the **Right-clik > Paste** manipulation if you don't have an `Insert` key.

---
class: center, middle
## VIM

.breadcrumbs[<a href="#1">Command Line Introduction</a>]



Some tools or command could open the infamous **VIM**, which is a text-based text editor bundled into your CLI.

If this happens (_and it will_), there's **one** imperative rule to follow:

**DO NOT PANIC!**

---
### Generalities

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#20">VIM</a>]

VIM can be unsetteling at first, until you know how it works.

The first thing to understand whith VIM is that it has three modes :
* **Normal** mode (the one you're in when VIM starts)
* **Command** mode (the one to use to save or quit)
* **Insert** mode (the one to use to insert text)

To go into each mode use this keys :

| From           | To      | Key   |
| :------------- | :------ | :---- |
| Normal         | Command | `:`   |
| Normal         | Insert  | `i`   |
| Command/Insert | Normal  | `Esc` |

---
### Normal mode

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#20">VIM</a>]

The **Normal** mode of VIM is the one you'r in when VIM starts. In this mode, you can move the cursor around with the arrow keys.

You can also use some commands to interact with the text:

| Command | Effect                                                           |
| :------ | :--------------------------------------------------------------- |
| `:`     | Enter **Command** mode.                                          |
| `i`     | Enter **Insert** mode.                                           |
| `x`     | Delete the first character after the cursor position.            |
| `dw`    | Delete a word, with the cursor standing before the first letter. |
| `dd`    | Delete the complete line the cursor is on.                       |
| `u`     | Undo the last command.                                           |

> At anytime, you can hit the `Esc` key to go back to the **Normal** mode.

---
### Command mode

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#20">VIM</a>]

The **Command** mode, which you can only access from the **Normal** mode, is the one you'll use to manipulate the file you're in.

To enter **Command** mode, hit the `:` key.

From there, you can use some commands:

| Command     | Effect                                                     |
| :---------- | :--------------------------------------------------------- |
| `q`         | Quit VIM (will fail if you have unsaved modifications).    |
| `w`         | Save the file and all its modifications.                   |
| `q!`        | Force VIM to quit (any unsaved modification will be lost). |
| `wq` or `x` | Save the file then quit VIM.                               |

---
## The `PATH` variable

.breadcrumbs[<a href="#1">Command Line Introduction</a>]

When you type a command in the CLI, it will try to see **if it knows this command**, by looking in some directories to see if there is an **executable file that matches the requested name**.

```bash
$> rubbish
bash: rubbish: command not found
```
> This means that the CLI failed to found the executable named `rubbish` in any of the directories where it looked.

The list of the directories (and their paths) in which the CLI searches is stored in the `PATH` variable, each of them being separated with a `:`.

You can print the content of your `PATH` variable to see this list:

```bash
$> echo $PATH
/usr/local/bin:/bin:/usr/bin:Users/Batman/BatRadar/bin
```
---
### Using non-system command

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#24">The `PATH` variable</a>]

New installed tools usually come with at least one new command that you can execute from the CLI.

But, if you'd want to execute this command, you would have to **manually go to the directory** containing the executable and **run the command there**.

```bash
$> cd Applications/Batsignal
$> ./batsignal
```
You could also run the command from anywhere by writing **the path to the executable**:

```bash
$> /Users/Batman/Application/Batsignal/batsignal
```
But, ideally, you would want to **just type the name of the command**, and see it executed.

For this, you need to **change the value** of your `PATH` variable.

---
### Updating the `PATH` variable

.breadcrumbs[<a href="#1">Command Line Introduction</a> > <a href="#24">The `PATH` variable</a>]

To add a new path in your `PATH` variable, you have to edit a special file, used by your CLI. This file depends upon the CLI you are using:

| CLI                 | File to edit |
| :------------------ | :----------- |
| Terminal / Git Bash | `~/.bashrc`  |
| [ZSH][zsh-site]     | `~/.zshrc`   |

Open up the adequate file (here `.bashrc`) from the CLI with `vim`...

```bash
$> vim ~/.bashrc
```
... and add this line at the bottom of your file (use `i` to enter _insert_ mode)

```vim
export PATH="path/to/directory:$PATH"
```
...with `path/to/directory` being **the path to the directory** that contains the command(s), **not the path to the command itself**.

Save the file (`Esc` then `:wq`) and restart your CLI.

[gitbash]: https://git-for-windows.github.io/
[zsh-site]: http://zsh.sourceforge.net/
[slide-git]: ../git

    </textarea>

    <script src='../../assets/remark.min.js'></script>
    <script src='../../assets/jquery-3.1.1.slim.min.js'></script>
    <script src='../../assets/uri-1.18.7.js'></script>

    <script>
      var slideshow = remark.create({
        highlightLines: true,
        highlightSpans: true,
        countIncrementalSlides: false
      });

      $('#slide-links .home-link').each(function() {
        var $a = $(this);

        var currentUri = URI(window.location.href);
        var home = currentUri.search(true).home

        if (typeof(home) == 'string' && home.match(/^[a-z0-9\-\_\.]+\/[a-z0-9\-\_\.]+(?:#.*)?$/i)) {
          $a.attr('href', 'https://github.com/' + home);
        } else if (typeof(home) == 'string') {
          $a.attr('href', home);
        } else if (currentUri.hostname() == 'localhost') {
          $a.attr('href', currentUri.path('').hash('').toString());
        }
      });

      var slides = $('.remark-slide-content');

      // Remove logo from body and add it to each slide
      $('#slide-logo').remove().prependTo(slides).show();

      // Remove links from body and add them to each slide
      $('#slide-links').remove().prependTo(slides).show();

      // Make all external links open a new window
      $('a[href]').not('.home-link').not('[href^="#"]').attr('target', '_blank');
    </script>
  </body>
</html>
